<a name="thedifferenttypesof...typesinscala"></a>

1\. The different types of... Types in Scala
========================================


This blog post came into being after a few discussions about Types in Scala after some of JavaOne's parties in 2013. After those discussions I figured that many questions are often repeated by different people, during their learning of Scala. I though that we didn't have a full list of all tricks what we can to with Types in Scala, so I decided to write such a list - giving real life examples why we'd need these types.


<a name="typeannotation"></a>

1.1\. Type Annotation
---------------
Scala has Type Inference, which means that we can skip telling the Type of something each time in the source code,
and instead we just use `val`s or `def`s without "saying the type explicitly in the source". This being explicit about
the type of something, is called an Type Annotation.

```scala
trait Thing
def getThing = new Thing

// without Type Annotation, the type is infered to be `Thing`
val infered = getThing

// with Type Annotation
val thing: Thing = getThing
```

In these situations, leaving out the Type Annotation is OK. Although you may decide to always annotate return types of public methods (*that's very good idea!*) in order to make the code more self-documenting.

In case of doubt you can refer to the below hint-questions to wether or not, include a Type Annotation.

* It it a parameter? **Yes**, you have to.
* Is it a public methods return value? **Yes**, for self-documenting code and control over exported types.
* Do you need to return a more general interface than the inferencer would find? **Yes**, otherwise you'd expose your implementation details for example.
* Else... No, don't include a Type Annotation.
* Related hint: Including Type Annotations speeds up compilation, also it's generally nice to see the return type of a method.

So we put Type Annotations after value names. Having this said, let's jump into the next topics, where these types will become
more and more interesting.

<a name="unifiedtypesystem-anyanyrefanyval"></a>

1.2\. Unified Type System - Any, AnyRef, AnyVal
-----------------------------------------

We refer to a Scala's typesystem as being "unified" because there is a "Top Type", `Any`. **This is different than Java**, which has "special cases" in form of primitive types (`int`, `long`, `float`, `double`, `byte`, `char`, `short`, `boolean`), which do not extend Java's "Almost-Top Type" - `java.lang.Object`.

![A Unified Type System](http://www.blog.project13.pl/wp-content/uploads/2012/12/skitch-5.png)

Scala takes on the idea of having one common Top Type for all Types by introducing `Any`. `Any` is a supertype of both `AnyRef` and `AnyVal`.

`AnyRef` is the "object world" of Java (and the JVM), it corresponds to `java.lang.Object`, and is the supertype of all objects.

`AnyVal` represents the "value world" of Java, such as `int` and it's friends.

Thanks to this hierarchy, we're able to define methods taking `Any` - thus being compatible with both `scala.Int` instances as well as `java.lang.String`:

```scala
class Person

val allThings = ArrayBuffer[Any]()

val myInt = 42             // Int, kept as low-level `int` during runtime

allThings += myInt         // Int (extends AnyVal)
                           // has to be boxed (!) -> becomes java.lang.Integer in the collection (!)

allThings += new Person()  // Person (extends AnyRef), no magic here
```

For the Typesystem it's transparent, though on the JVM level once we get into `ArrayBuffer[Any]` our Int instances will have to be packed into objects. Let's investigate the above example's by using the Scala REPL and it's `:javap` command (which shows the generated bytecode for our test class):

```
35: invokevirtual #47  // Method myInt:()I
38: invokestatic  #53  // Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
41: invokevirtual #57  // Method scala/collection/mutable/ArrayBuffer.$plus$eq:(Ljava/lang/Object;)Lscala/collection/mutable/ArrayBuffer;
```

You'll notive that `myInt` is still carrying the value of a `int primitive` (this is visible as `I` at the end of the `myInt:()I` *invokevirtual* call). Then, right before adding it to the ArrayBuffer, scalac inserted a call to `BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer` (a small hint for not frequent bytecode readers, the method it calls is: `public Integer boxToInteger(i: int)`). This way, by having a smart compiler and treating everything as an object in this common hierarchy we're able to get away from the "but primitives are different" edge-cases, at least at the level of our Scala source code - the compiler takes care of it for us. On JVM level, the distinction is still there of course, and scalac will do it's best to keep using primitives wherever possible, as operations on them are faster, and take less memory (objects are obviously bigger than primitives).


On the other hand, we can limit a method to only be able to work on "lightweight" Value Types:

```scala
def check(in: AnyVal) = ()

check(42)    // Int -> AnyVal
check(13.37) // Double -> AnyVal

check(new Object) // -> AnyRef = fails to compile

```

In the above example I've used a TypeClass `Checker[T]` and a type bound, which will be discussed below. The general idea is that this method will only take value classes, be it Int or our own Value Type. While probably not used very often, it shows how nicely the typesystem embraces java primitives, and brings them into the "real" type system, and not as a separate case, as is the case with Java.

<a name="thebottomtypes-nothingandnull"></a>

1.3\. The Bottom Types - Nothing and Null
-----------------------------------
In Scala everything has "some" type... but have you ever wondered how the type inferencer can still work, and infer sound types when working with "weird" situations like throwing exceptions? Let's investigate the below "if/else throw" example:

```
val thing: Int =
  if (test)
    42                             // : Int
  else
    throw new Exception("Whoops!") // : Nothing
```

As you can see in the comments, the type of the if block is `Int` (easy), the type of the else block is `Nothing` (interresting). The inferencer was able to infer that the `thing` value, will only ever be of type `Int`. This is because of the **Bottom Type** property of Nothing. You can think of it as if:

"`Nothing extends anything`"

Type inference always looks for the "common type" of both branches in an if stamement, so if the other branch here is a Type that extends everything, the infered type will automatically be the Type from the first branch.

```
Types visualized:

           [Int] -> ... -> AnyVal -> Anything
Nothing -> [Int] -> ... -> AnyVal -> Any
```

The same reasoning can be applied to the second Bottom Type in Scala - `Null`.

```
val thing: String =
  if (test)
    "Yay!"  // : String
  else
  	null    // : Null
```

The type of `thing` is as expected, String. `Null` follows ALMOST the same rules as Nothing. I'll use this case to take a small detour to talk about inference, and the differences between AnyVals and AnyRefs.

```
Types visualized:

        [String] -> AnyRef -> Any
Null -> [String] -> AnyRef -> Any

infered type: String
```

Let's think about `Int` and other primitives, which cannot hold null values. To investigate this case let's drop into the REPL and use the `:type` command (which allows to get the type of an expression):

```
scala> :type if (false) 23 else null
Any
```

This is different than the case with a String object in one of the branches. Let's look into the types in detail here, as `Null` is a bit less "extends everything" than `Nothing`. Let's see what `Int` extends in detail, by using `:type` again on it:

```
scala> :type -v 12
// Type signature
Int

// Internal Type structure
TypeRef(TypeSymbol(final abstract class Int extends AnyVal))
```

The verbose option adds a bit more information here, now we know that `Int` is an `AnyVal` - this is a special class representing value types - which cannot hold `Null`. If we look into <a href="https://github.com/scala/scala/blob/v2.10.3/src/library/scala/AnyVal.scala">AnyVal's sources</a>, we'll find:

```
abstract class AnyVal extends Any with NotNull
```

I'm bringing this up here because the core functionality of AnyVal is so nicely represented using the Types here. *Notice the `NotNull` trait!*

Coming back to the subject why the common Type for our if statement with an `AnyVal` on one code block and a `null` on the other one was Any and not something else. The one sentence way to define it is: `Null extends all AnyRefs` whereas `Nothing extends anything`. As AnyVals (such as numbers), are not in the same tree as AnyRefs, the only common Type between a number and a `null` value is Any - which explains our case.

```
Types visualized:

Int  -> NotNull -> AnyVal -> [Any]
Null            -> AnyRef -> [Any]

infered type: Any
```

<a name="typeofan`object`"></a>

1.4\. Type of an `object`
-------------------

Scala `object`s are implemented via classes (obviously - as it's the basic building block on the JVM),
but you'll notice that we cannot get it's type the same way as we would with an simple class...

I surprisingly often, would get the question on how to pass an object into a method. Just saying `obj: ExampleObj` won't work
because that's already referring to the instance, so there's a member called `type` which should be used in such cases.

How it might look like in your code is explained by the below example:

```
object ExampleObj

def takeAnObject(obj: ExampleObj.type) = {}

takeAnObject(ExampleObj)
```

<a name="typevarianceinscala"></a>

1.5\. Type Variance in Scala
----------------------

In Scala container types are **NOT variant at all by default**!

This means that for a container `List[Fruit]` you cannot insert Apples into it,
even if an `class Apple extends Fruit`.

Variance in Scala is defined by using `+` and `-` signs in front of type parameters.

http://www.slideshare.net/dgalichet/demystifying-scala-type-system

<table>
    <thead>
    <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Scala Syntax</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td class="bold">Invariant</td>
        <td>
            <code>C[T']</code> and <code>C[T]</code> are <strong>not</strong> related
        </td>
        <td>
            <code>C[T]</code>
        </td>
    </tr>
    <tr>
        <td class="bold">Covariant</td>
        <td>
            <code>C[T']</code> is a subclass of <code>C[T]</code>
        </td>
        <td>
            <code>C[+T]</code></td>
    </tr>
    <tr>
        <td>
            <strong>Contravariant</strong>
        </td>
        <td>
            <code>C[T]</code> is a subclass of <code>C[T']</code>
        </td>
        <td>
            <code>C[-T]</code></td>
    </tr>
    </tbody>
</table>



There are (at least) two nice and very intuitive examples of this in Scala. One being "any collection", where we'll use a `List[A]
` as our example, and functions. A `List` is defined as `List[+A]` in Scala, so the below code is valid:

```
class Human
class Coder extends Human


```

TODO


<a name="traitsmix-ins"></a>

1.6\. Traits (mix-ins)
----------------

Scala has Traits, which you might already know from other languages, under such names as Mix-In or Module (in Ruby's case).

<a name="traitsasin"interfaceswithimplementation"###"></a>

### 1.6.1\. Traits, as in "interfaces with implementation" ###

First, let's take a look as the simplest thing possible about traits:
how we can basically treat a type with multiple traits mixed in, as if it is implementing these "interfaces with implementation",
as you might be tempted to call them if comming from Java-land:

```scala
class Base { def b = "" }
trait Cool { def c = "" }
trait Awesome { def a ="" }

class BA extends Base with Awesome
class BC extends Base with Cool

// as you might expect, you can upcast these instances into any of the traits they've mixed-in
val ba: BA = new BA
val bc: Base with Cool = new BC

val b1: Base = ba
val b2: Base = bc

ba.a
bc.c
b1.b
```

So far this should have been relatively well known to you. Now let's to into the world of the "diamond problem",
which people who know C++ might have been expecting. Basically "The Diamond Problem" is a situation during multiple inheritance
where we're not sure to what we want to refer to. The below image ilustrates the problem, if you would think of traits as if they were
directly multiple inheritance:

<a name="typelinearizationvs.thediamondproblem###"></a>

### 1.6.2\. Type Linearization vs. The Diamond Problem ###

![diamond-inheritance-problem](http://upload.wikimedia.org/wikipedia/commons/thumb/8/8e/Diamond_inheritance.svg/220px-Diamond_inheritance.svg.png)

For the "diamond problem" to appear, it's enough if we have one overriding implementation in `B` or/and `C`. This introduces an ambiguity when calling the common method in `D`, did we inherit the version of the method from `C` or from `B`? In Scala's case the case with only one overriding method is very simple - the override wins. But let's work through the more complex case:

* class `A` defines a method `common` returning `a`,
* trait `B` DOES override `common` to return `b`,
* trait `C` DOES override `common` to return `c`,
* class `D` extends both `B` and `C`,
* which version of the `common` method does class `D` inherit? The overriden impementation from `C`, or theone from `B`?

This amgiguity is a pain point of every multiple-inheritance-like mechanism. Scala solves this problem by so called **Type Linearization**.
In other words, given a diamond class hierarchy, we are **always** (and **deterministically**) able to determine what will be called when inside D we call `common`.
Let's put this into code and then talk about linearization:

```scala
trait A { def common = "A" }

trait B extends A { override def common = "B" }
trait C extends A { override def common = "C" }

class D1 extends B with C
class D2 extends C with B
```

The results will be as follows:

```scala
(new D1).common == "C"

(new D2).common == "B"
```

The reason for this is that Scala applied the type linearization for us here. The algorithm goes like this:

* start building a list of types, the first element is the type we're linearizing right now,
* expand each supertype recursively and put all their types into this list (it should be flat, not nested),
* remove duplicates from the resulting list, by scanning it from the left, and removing a type that you've already "seen"
* done.

Let's apply this algorithm on our diamond example by hand, to verify why `D1 extends B with C` (and `D2 extends C with B`) yielded the results they did:


```scala
// start with D1:
B with C with <D1>

// expand all the types until you rach Any for all of them:
(Any with AnyRef with A with B) with (Any with AnyRef with A with C) with <D1>

// remove duplicates by removing "already seen" types, when moving left-to-right:
(Any with AnyRef with A with B) with (                            C) with <D1>

// write the resulting type nicely:
Any with AnyRef with A with B with C with <D1>
```

So when calling the `common` method, it's now very simple to decide which version we want to call: we simply look at the linearized type,
and try to resolve the method by going from the right in the resulting linearized type. In the case of `D1`, the "rightmost" trait providing an implementation of `common` is `C`, so it's overriding the implementation provided by `B`. The result of calling `common` inside `D1` would be `"c"`.

You can wrap your head around this method by trying it out on the `D2` class - it should linearize with `B` after `C`, thus yielding a `"b"` if you'd run the code.
Also it's rather easy to resolve the simpler cases of linearization by just thinking "rightmost wins", but this is quite an simplification, which while helpful, does not give the full picture about the algorithm.

It is worth mentioning that using this technique we also know *"who is my `super`?"*. It's as easy as "looking left" in the linearized type, from wherever class you want to check who your superclass is. So for example in our case (`D1`), the superclass of `C` is `B`.



<a name="refinedtypesrefinements"></a>

1.7\. Refined Types (refinements)
---------------------------
Refinements are very easy to explain as "subclassing without naming the subclass". So in source code it would look like this:

```scala
class Entity

trait Persister {
  def doPersist(e: Entity) = {
    e.persistForReal()
  }
}

// our refined instance (and type):
val refinedMockPersister = new Persister {
  override def doPersist(e: Entity) = ()
}
```



<a name="typealias"></a>

1.8\. Type Alias
----------
It's not really another kind of type, but a trick we can use to make our code more readable:

```scala
type User = String
type Age = Int

val data:  Map[User, Age] =  Map.empty
```

Using this trick the Map definition now suddenly "makes sense!". If we'd just use a  ### `String => Int`,
we'd make the code less readable. Here we can keep using our primitives (maybe we need this for performance etc),
but **name them** so it makes sense for the future reader of this class.

<a name="abstracttypemember"></a>

1.9\. Abstract Type Member
--------------------

Let's now go deeper into the use cases of Type Aliases, which we call Abstract Type Members.

With Abstract Type Members we say "I expect someone to tell me about some type - I'll refer to it by the name MyType".
It's most basic function is allowing us to define generic classes (templates), but instead of using the `class Clazz[A, B]` syntax, we name them inside the class, like this:

```scala
trait SimplestContainer {
  type A      // Abstract Type Member

  def value: A
}
```

Which for Java folks may seem very similar to the `Container<A>` syntax at first, but it's a bit more powerful as we'll see in the section about *Path-dependent Types*, as well as in the below example.

todo; Then, this is how we would implement this trait:

```scala
object IntContainer extends SimplestContainer {
  type A = Int

  def value = 42
}
```

So we "provide the type" using a Type Alias on line 2 here, and now we can implement the value method, as it's type is known.



<a name="self-recursivetype"></a>

1.10\. Self-Recursive Type
-------------------

This we brought up with <a href="http://andrzejgrzesik.info">Andrzej Grzesik</a>, while discussing my blog post series about various Type Systems (my favourite topic :-)). Andrzej followed up <a href="http://andrzejgrzesik.info/2013/09/29/container-types/">on his blog, by explaining how the self-recursive generic type trick works in Java's Enum class</a>. Another nice blog post about this type-trick, is <a href="http://blog.jooq.org/2013/06/28/the-dangers-of-correlating-subtype-polymorphism-with-generic-polymorphism/">The dangers of correlating subtype polymorphism with generic polymorphism</a>, where lukaseder points out why/where this pattern may cause you trouble.

```scala
class Apple
```


<a name="typeclass"></a>

1.11\. Type Class
----------

```scala
trait Writes[In, Out] {
  def write(it: In): Out
}

implicit val jsonWriter = new Writes[Person, Json] {
  def writes(p: Person) = Json.toJson(p)
}

implicit class Writeable[A] {
  def write(implicit writes: Writes[A])
}
```

<a name="typeconstructor"></a>

1.12\. Type Constructor
----------------
Also known as *Higher Kinds*, Type Constructors act pretty much like functions, but on the type level.
That is, if in normal programming you can have a function that takes a value `a` and returns a value `b` based on the previous one, then in type-level programming you'd think of a `List[A]` being a type constructor, that is:

* `List[A]` takes a type parameter (`A`),
* by itself it's not a valid type, you need to fill in the A somehow - construct the type,
* by fillinf it in with `Int` you'd get `List[Int]` which is a concrete type.

Using this example, you can see how similar it is to normal constructors - with the only difference that here we work on types, and not instances of objects. It's worth reminding here that in Scala it is not valid to say something is of type `List`, *unlike in Java* where javac would put the `List<Object>` for you. Scala is more strict here, and won't allow us to use `just a List` in the place of a type, as it's expecting a real type - not a type constructor.

Related to this subject is that with **Scala 2.11.x** we're getting a new power user command in the REPL - the `:kind` command. It allows you to check if a type is higher kind or not. Let's check it our on a simple type constructor, such as `List[+A]` first:

```scala
// Welcome to Scala version 2.11.0-M5 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0-ea).
// Type in expressions to have them evaluated.

:kind List
// scala.collection.immutable.List's kind is F[+A]

:kind -v List
// scala.collection.immutable.List's kind is F[+A]
// * -(+)-> *
// This is a type constructor: a 1st-order-kinded type.
```

Here we see that scalac is able to tell us that `List`, in fact, is a type constructor (it's way more talkative when used with the `-v`erbose option). Let's investigate the syntax right above this information: `* -> *`. This syntax is widely used to represent kinds, and actually I found it quite Haskell inspired - as this is the syntax Haskell uses to print types of functions. The most intuitive way to read it out loud would be "takes one type, returns another type". You might have noticed that we've omitted something from Scala's exact output, the plus sign from the relation (as in:`* -(+)-> *`), this means variance bounds and you can read up in detail about variance in section (TODO LINK TO VARIANCE).

As already mentioned, `List[A]` (or `Option[A]`, or `Set[A]`... or anything that has one type parameter) is the simplest case of a type constructor - these take one parameter. Let's take a look how type constructors with multiple type parameters are represented by investigating Scala's `Either[+A, +B]`:

```scala
:kind -v Either
// scala.util.Either's kind is F[+A1,+A2]
// * -(+)-> * -(+)-> *
// This is a type constructor: a 1st-order-kinded type.
```

So here we have a type that needs two type parameters in order to be able to construct a real type. This could be understood as "A type constructor that takes a Type, and returns a type constructor that takes another type, and returns the real type". If we think back to functions and try to apply the same thinking we could say that an addition (`def +(a: Int, b: Int)`) is basically a function taking `a` which returns a function taking `b`, and just then we apply the computation. For functions this can be expresses easily by using the multiple parameter lists syntax (`def +(a: Int)(b: Int)`). It's a very useful way of thinking about applying functions (and types), as it allows us to partially apply a function, and then pass it somewhere else - where someone will pass in the missing parameter. Now we just need to bring this thinking into the type level! Which means that we might partially construct a type - by saying that in `Either[A, B]` we want to bind `A` to `Int`, but we have no idea about `B` yet - someone else will know.
This idea opens up the way to (Type Lambdas)[#type-lambda] which have a full chapter about them.

And a small bonus for the curious, the kind of a concrete type is simply A (no place for any `->` in there!).

```scala
:kind String
// java.lang.String's kind is A
```

<a name="selftypeannotation"></a>

1.13\. Self Type Annotation
--------------------

**Self Types** are used in order to "require" that, if another class uses this trait,
it should also provide implementation of whatever it is that you're requireing.

Let's look at an example where a service requires some Module which provides other services.
We can state this using the following Self Type Annotation:

```scala
trait Module {
  lazy val serviceInModule = new ServiceInModule
}

trait Service {
  this: Module =>

  def doTheThings() = serviceInModule.doTheThings()
}
```

The second line can be read as "I'm a Module". It might seem yield the exactly same But how does this differ from extending `Module` right away?

which means that someone will have to give us this Module at instanciation time:

```scala
trait TestingModule extends Module { /*...*/ }

new Service with TestingModule
```

If you were to try to instanciate it without mixing in the required trait it would fail like this:

```scala
new Service

// class Service cannot be instantiated because it does not conform to its self-type Service with Module
//              new Service
//              ^
```

You should also keep in mind, that it's OK, to specify more than one trait when using the self-type syntax.
And while we're at it, let's discuss why it is called self-type (except for the "yeah, it makes sense" factor). Turns out a popular style (and possibility) to write it looks like this:

```scala
class Service {
  self: MongoModule with APIModule =>

  def delegated = self.doTheThings()
}
```

In fact, you can use any identifier (not just `this` or `self`) and then refer to it from your class.

<a name="phantomtype"></a>

1.14\. Phantom Type
------------
Now we're starting to get into the more interesting Types! :-)

Phantom Types are a mean of staticly validating your sources, during compile time.
It's used in many libraries, to prevent you from using some API, with an object in "not the right state".

To set the stage for our Phantom Type usage let's first define a `ServiceHandle` class,
and `trait`s to represent the state it is in. We want to prevent users of our API from calling `stop()` on an already
`Stopped` instance, as well as prevent them from calling `start()` on an already `Running` instance.

```scala
// the traits are expected to be only used with our ServiceHandle,
// which we nicely express using Self Type Annotations.
trait Stopped { this: ServiceHandle => }
trait Running { this: ServiceHandle => }
```

Now that we have our Types prepared, let's look at how the implementation will look like:

```scala
class ServiceHandle private (id: Id)
object ServiceHandle {
  def create(id: Id) = new ServiceHandle(id) with Stopped
}
```

Here, during instanciation of the class, we mix in the `Stopped` trait right away.
We've used this trick before in this blog post (series), but now it's finally time to explain it in detail.

Turns out that the type of this newly created ServiceHandle is not only `ServiceHandle` but...
`ServiceHandle with Stopped`. It may seem underwhelming at first that "that's it",
but let's move on to the `start` and `stop` commands to see why this us so nice interesting.

```scala
def start(s: ServiceHandle with Stopped) = {
  s.start()
  new ServiceHandle(s.id) with Running
}
```

And we can do the same for stopping a Service. Other useful methods would be,
`Id => Either[ServiceHandle with Stopped, ServiceHandle with Running]` which's implementation you can easily imagine.

```scala
def stop(s: ServiceHandle with Running) = {
  s.stop()
  new ServiceHandle(s.id) with Stopped
}
```

TODO MAKE BETTER EXAMPLES



Fun Java Fact: A similar end-result - failing during compilation - can also be done in Java, using annotation processors and Annotated types (you should check out Adam Warski's example on this if you're curious).

<a name="structuraltype"></a>

1.15\. Structural Type
---------------

Strucural Types are often compared to "*type-safe duck typing*", which is quite a good comparation if you'd want to get some intuition for it.

So far we've only been thinking about types in terms of "*does it implement interface X?*". With **structural types** we can go a step further and start reasoning
about the structure of a given object (hence the name). When using structure to check if something matches such type we have to change our question to: "*does it have a method with this signature?*".

Let's look at a very popular use-case in action, to see why it is so powerful. Imagine that you have many classes of things that can be *closed*. In Java-land one would usualy implement the `java.io.Closeable` interface in order to make it possible to write some common `Closeables` utility class (in fact, *Google Guava* provides such an utility class). Now imagine that someone also implemented a `MyOwnCloseable` class but didn't extend `java.io.Closeable`. Your `Closeables` library would be stuck - as due to the static typing, you would not be able to pass instances of `MyOwnCloseable` into it. Let's solve this problem via using Structural Typing:

```scala
type JavaCloseable = java.io.Closeable
// reminder, it's body is: { def close(): Unit }

class MyOwnCloseable {
  def close(): Unit = ()
}


// method taking a Structural Type
def closeQuietly(closeable: { def close(): Unit }) =
  try {
    closeable.close()
  } catch {
    case ex: Exception => // ignore...
  }


// takes a java.io.File (implements Closeable):
closeQuietly(new StringReader("example"))

// takes
closeQuietly(new MyOwnCloseable)
```

The structural type is defined on the method's parameter here. It basically says that the only thing we expect from the type that should be passed in here
is that it should have this method. It could have more methods - so it's not an exact match but the minimal set of methods a type has to define in order to be valid for us.

Another fact to keep in mind when using **Structural Typing is that it actually has huge (negative) runtime performance implications, as it is actually implemented
using reflection**. We won't look into the byte code for this case, but remember that it's very easy to investitage the generated bytecode for scala (or java) classes, by using :javap in the Scala REPL, so you can check it out yourself.

Before we move over to the next subject, let's briefly touch on a small but neat stype tip.
Imagine that your Structural Type is quite big, an example would be - a type representing something that you can open, work on, and then must close.
By using a Type Alias (described in detail in another section) with the Structural Type, we're able to separate the type definition from the method, where we want to take in such instance:

```scala
type OpenerCloser = {
  def open(): Unit
  def close(): Unit
}

def on(it: OpenerCloser)(fun: OpenerCloser => Unit) = {
  it.open()
  fun(it)
  it.close()
}
```

So using this type alias, we've made the `def` way cleaner - so I'd highly recommend type aliasing bigger structural types. And one last warning, always check
if you really need to reach for structural typing, and cannot do it in some other way - as it has quite some negative performance impact.

<a name="pathdependenttype"></a>

1.16\. Path Dependent Type
-----------------------

This Type allows us to type-check on a Type internal to another class. This may seem weird at first, but is very intuitive once you see it:

```scala
class Outer {
  class Inner
}

val out1 = new Outer
val out1in = new out1.Inner // concrete instance, created from inside of Outer

val out2 = new Outer
val out2in = new out2.Inner // another instance of Inner, with the enclosing instance out2

// the path dependent type. The "path" is "inside out1".
type PathDep1 = out1.Inner


// type checks

val typeChecksOk: PathDep1 = out1in
// OK

val typeCheckFails: PathDep1 = out2in
// <console>:27: error: type mismatch;
// found   : out2.Inner
// required: PathDep1
//    (which expands to)  out1.Inner
//       val typeCheckFails: PathDep1 = out2in
```

The ey to understand here isthat "each class Outer, has it's own Inner class", so it's a different Type - dependent on which path we use to get there.

Using this kind of typing is useful, we're able to enforce getting the type from inside of a concrete parameter. An example of a signature using this typing would be:

```scala
class Parent {
  class Child
}

class ChildrenContainer(p: Parent) {
  type ChildOfThisParent = p.Child

  def add(c: ChildOfThisParent) = ???
}
```

Using the path dependent type we have now encoded in the type system, the logic,
that this container should only contain children of this parent - and not "any parent".

We'll see how to require the "child of any parent" Type using Type Projectsions in the next section.


<a name="typeprojection"></a>

1.17\. Type Projection
---------------
Type Projections are similar to Path Dependent Types, in the way that they allow you to refer to a type of an inner class. In terms of syntax, you path your way into the structure of inner classes, splitting them with a `#` sign (hash sign, pound sign). Let's start out by showing the first and main difference between these path dependent types (the "." syntax) vs. type projections (the "#" syntax):

```scala
// our example class structure
class Outer {
  class Inner
}

// Type Projection (and alias) refering to Inner
type OuterInnerProjection = Outer#Inner

val out1 = new Outer
val out1in = new out1.Inner
```

Another nice intuition about path dependent vs. projections is that Type Projections can be used for "type level programming" ;-)

<a name="existentialtypes"></a>

1.18\. Existential Types
-----------------

Existential Types are something that deeply relates to Type Erasure, which JVM languages "have to live with".

```scala
val thingy: Any = ???

thingy match {
  case l: List[a] =>
     // lower case 'a', matches all types... what type is 'a'?!
}
```

We don't know the type of `a`, because of runtime type erasure. We know though that List is a type constructor, `* -> *`, so there must have been some type, it could have used to construct a valid `List[T]`. This "some type", is the **existentional type**!

Scala provides a shortcut for it:

```scala
List[_]
 //  ^ some type, no idea which one!
```

Let's say you're working with some Abstract Type Member, that in our case will be some Monad.
We want to force users of our class into using only `Cool` instances within this Monad, because for example,
only for these Types our Monad has any meaning. We can do this via Type Bounds on these *Existential Type T*:

```scala
type Monad[T] forSome { type T >: Cool }
```

http://mikeslinn.blogspot.com/2012/08/scala-existential-types.html



