== Structural Type

Strucural Types are often compared to "*type-safe duck typing*", which is quite a good comparation if you'd want to get some intuition for it.

So far we've only been thinking about types in terms of "*does it implement interface X?*". With **structural types** we can go a step further and start reasoning
about the structure of a given object (hence the name). When using structure to check if something matches such type we have to change our question to: "*does it have a method with this signature?*".

Let's look at a very popular use-case in action, to see why it is so powerful. Imagine that you have many classes of things that can be *closed*. In Java-land one would usualy implement the `java.io.Closeable` interface in order to make it possible to write some common `Closeables` utility class (in fact, *Google Guava* provides such an utility class). Now imagine that someone also implemented a `MyOwnCloseable` class but didn't extend `java.io.Closeable`. Your `Closeables` library would be stuck - as due to the static typing, you would not be able to pass instances of `MyOwnCloseable` into it. Let's solve this problem via using Structural Typing:

```scala
type JavaCloseable = java.io.Closeable
// reminder, it's body is: { def close(): Unit }

class MyOwnCloseable {
  def close(): Unit = ()
}


// method taking a Structural Type
def closeQuietly(closeable: { def close(): Unit }) =
  try {
    closeable.close()
  } catch {
    case ex: Exception => // ignore...
  }


// takes a java.io.File (implements Closeable):
closeQuietly(new StringReader("example"))

// takes
closeQuietly(new MyOwnCloseable)
```

The structural type is defined on the method's parameter here. It basically says that the only thing we expect from the type that should be passed in here
is that it should have this method. It could have more methods - so it's not an exact match but the minimal set of methods a type has to define in order to be valid for us.

Another fact to keep in mind when using **Structural Typing is that it actually has huge (negative) runtime performance implications, as it is actually implemented
using reflection**. We won't look into the byte code for this case, but remember that it's very easy to investitage the generated bytecode for scala (or java) classes, by using :javap in the Scala REPL, so you can check it out yourself.

Before we move over to the next subject, let's briefly touch on a small but neat stype tip.
Imagine that your Structural Type is quite big, an example would be - a type representing something that you can open, work on, and then must close.
By using a Type Alias (described in detail in another section) with the Structural Type, we're able to separate the type definition from the method, where we want to take in such instance:

```scala
type OpenerCloser = {
  def open(): Unit
  def close(): Unit
}

def on(it: OpenerCloser)(fun: OpenerCloser => Unit) = {
  it.open()
  fun(it)
  it.close()
}
```

So using this type alias, we've made the `def` way cleaner - so I'd highly recommend type aliasing bigger structural types. And one last warning, always check
if you really need to reach for structural typing, and cannot do it in some other way - as it has quite some negative performance impact.

